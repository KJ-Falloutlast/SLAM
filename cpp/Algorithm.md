# 1.数据结构的基本概念
## 1-1.数据
1. 定义
   1. 能输入计算机且能被计算机处理的各种符号的集合
      1. 信息的载体
      2. 是对客观实物符号化的表示
      3. 能够被计算机识别，存储和加工
2. 包括
   1. 数值型的数据：整数，实数
   2. 非数值型的数据:文字，图像，图形，声音
## 1-2.数据元素和数据项
1. 数据元素
   1. 是数据的基本单位，在计算机中作为一个整体进行考虑和处理
   2. 也简称为元素，记录，顶点
2. 数据项：构成数据元素的不可分割的最小单位
   1. 关系：
      1. 数据>数据元素>
               1. 数据项
               2. 数据对象
      2. 例如:**学生表 >个人记录>学号**
3. 数据对象
   1. 是性质相同的数据元素的集合，是数据的子集
   2. 例如:
      1. 整数数据对象为$N = {0, +-1,+-2}$
      2. 字母字符是数据对象为$char = {'a', 'b', 'c'}$
      3. 学籍表也可看做数据对象
   3. 关系  
      1. 数据元素-组成数据的基本单位
         1. 与数据的关系:是集合的个体
      2. 数据对象-性质相同的数据元素的集合
         1. 与数据的关系: 集合的子集
## 1-3.数据结构
1. 数据结构
   1. 数据元素相互之间的关系为结构
   2. 是指相互之间存在一种或多种特定关系的数据元素的集合
   3. 或者说，数据结构是带结构的数据元素的集合
2. 内容
   1. 数据元素之间的逻辑关系，为**逻辑结构**
   2. 数据元素及其关系在计算机内存中的表示(又称**映像**)，称为数据的**物理结构**或者**储存结构**
   3. 数据的**运算和实现**，即对数据元素可以施加的操作以及这些操作在相应存储结构上的实现
3. **逻辑结构**
   1. 描述数据元素之间的逻辑关系
   2. 与数据的存储无关，独立于计算机
   3. 是从具体问题抽象出来的数学模型
   4. 种类
      1. 划分方法1
         1. 线性结构:有且仅有一个开始和一个终端节点，并且所有的 节点最多*只有一个直接前趋和一个直接后继*.例如：线性表，栈，队列，串
         2. 非线性结构：一个结点可能有*多个直接前驱和直接后继*，例如：数，图
      2. 划分结构2:![逻辑结构](../pictures/逻辑结构.png)
         1. 集合结构:结构中的数据元素之间除了**同属于一个集合**的关系外，无任何其他关系
         2. 线性结构:结构中的数据元素之间存在这**一对一**的线性关系
         3. 树形结构:结构中的数据元素之间存着**一对多**层次关系
         4. 图状结构：结构中的数据元素之间存在这**多对多**的任意关系
4. 物理结构
   1. 数据元素及其关系在计算机存储器中的结构(**存储方式**)
   2. 是数据结构在计算机的表示
   3. 划分结构
      1. 顺序存储结构![顺序存储](../pictures/顺序存储结构.png)
         1. 用一组*连续*的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的**存储位置**来表示
         2. C中用数组来实现顺序存储结构
      2. 链式存储结构![链式存储](../pictures/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)
         1. 用一组任意的存储单元存储数据元素，数据元素之间的逻辑结构用指针来表示
         2. C中与*指针*来实现链式存储结构
      3. 索引存储结构
         1. 在存储结点信息的同时，还建立了索引表
         2. 索引表中的每一项为*索引项*
         3. 一遍形式是：(index, addr)
         4. 关键字是唯一标识一个结点的数据项
         5. 若一个结点对应1个索引，则索引表为*稠密索引*；若一组结点对应1个索引，则索引表为*稀疏索引*
      4. 散列存储结构![散列表](../pictures/散列表.png)
         1. 根据结点的关键字直接计算出该结点的存储地址
5. 逻辑结构和存储结构的关系
   1. 存储结构是**逻辑关系的映像和元素本身的映像**
   2. **逻辑结构是数据结构的抽象，存储结构是数据结构的实现**

## 1-4.数据类型和抽象数据类型
1. 在编程时，必须对程序中出现的每个变量， 常量或者表达式，明确说明他们所属的类型
   1. 例如，在C中
      1. int, float,double**基本数据类型**
      2. 数组，结构体， 共用体，枚举**构造数据类型**
      3. 指针，void类型
      4. typedef自定义
2. 高级语言中的数据类型明显或隐含地规定了程序执行期间的变量和表达所有可能的取值范围，以及在这些数值范围上所允许的操作   
   1. 例如c中，int i, 表示i从$[-min, max]$,那么它可以在整数集上面进行+-*/
   2. 作用
      1. 约束变量或者常量的*取值操作*
      2. 约束变量或者常量的*操作*
3. 数据类型和抽象数据类型
   1. 数据类型定义(Data Type): $数据类型 = 值的集合 + 值集合的操作$
   2. 抽象数据类型定义(Abstract Data Type,ADT): $抽象数据类型 = 数学模型 + 数学模型上的操作$
      1. 例如:模型 = 圆， 操作 = {面积， 周长..}
      2. 注意
         1. 由用户定义，从问题抽象出*数据模型*(逻辑结构)
         2. 包括定义在数据模型上的一组**抽象运算**
         3. 不考虑计算机内的具体存储结构和运算的具体实现算法
      3. 抽象数据类型的形式定义
         1. 用(D, S, P)三元组表示
         2. D：数据对象(data)
         3. S:D上的关系集(set)
         4. P:是对D的基本操作集(operation)
         5. 格式![抽象数据类型](../pictures/抽象数据类型.png)
            1. 数据对象，数据关系的定义用伪代码描述
            2. 基本操作的定义格式为
               1. 基本操作名(参数表)
                  1. 赋值参数只为操作提供输入值
                  2. 引用参数以&打头，除提供输入值外，还将返回操作结果(**例如pow(&x, &y)**)
               2. 初始条件（初始条件的描述）
                  1. 描述操作执行前数据结构和参数应该满足的条件，若不满足则**操作失败**，并返回出错信息，若初始条件为空，则省略
               3. 操作结果(操作结果的描述)
                  1. 说明操作正常完成后，数据结构的变化状况和应该返回的结构
         6. 例：ADT：Circle ![圆](../pictures/抽象数据类型（圆）.png)

**本课程中用的是类C来描述的(介于伪代码和C语言)**
```cpp
ADT Circle{
   数据对象: D = {r, x, y | r, x, y 均是实数 }
   数据关系: R = {<r, x, y> | r为半径，<x,y>为圆心坐标}
   基本操作:
   Circle(&C,r,x,y){
      操作结果:构造一个圆
   }    
   double Area(C)
      初始条件:圆存在
      操作结构:计算面积
   double Circumference(C)
      初始条件:圆存在
      操作结果:计算周长
}ADT Circle
```
例2.定义复数
```cpp
ADT Complex{
   D = {r1, r2 | r1, r2为实数}
   S = {<r1, r2> | r1是实部， r2是虚部}
   assign (&C, v1, v2)
      初始条件:空的复数C已经存在
      操作结果:构造复数C，r1, r2分别被赋以参数v1, v2
   destroy(&C)
      初始条件:复数C已存在
      操作结构:复数C被销毁
   getReal(C, &realPart)
      初始条件：复数已经存在
      操作结果: 用realPart返回复数Z的虚部值
   getImag(C, &ImagPart)
      初始条件:复数已存在
      操作结果:用ImagPart返回复数C的虚部值
   Add(z1, z2, &sum)
      初始条件:z1,z2是复数
      操作结构：sum返回2个复数之和
}ADT Complex
```

## 1-5.算法和算法分析
### 1.定义
1. 定义
   1. 对特定问题的求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。
   2. <font color = red>算法解决问题的方法和步骤</font>
2. 算法的描述
   1. 自然语言：英语，中文
   2. 流程图：传统流程图，NS流程图
   3. 伪代码：类语言(类C语言)
3. 算法和程序
   1. 算法是解决问题的一种方法或一个过程，考虑如何将<font color = red>输入转换为输出</font>
   2. *程序*是用某种程序设计语言对算法的具体实现
   3. 程序 = 数据结构 + 算法
      1. 数据结构通过算法实现操作
      2. 算法由数据结构设计程序
4. 算法特性(5个特性)
   1. <font color = red>有穷性</font>:一个算法总是在执行有穷步后结束，且每一步都在有穷时间内完成
   2. 确定性：算法的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
   3. 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作有限次来实现
   4. 输入：一个算法有0个或多个输入
   5. 输出：有一个或多个输出
5. 算法的设计要求
   1. 正确性(Correctness):算法满足问题的要求，能正确解决问题。<font color = red>要注意</font>
      1. 程序*不含语法错误*
      2. 程序对于*几组输入数据*能够得出满足要求的结果
      3. 程序对于**精心选择的，典型，苛刻且带有刁难性的**的几组输入数据能够得出满足要求的结果
      4. 程序对于**一切合法的输入数据**都能得到满足要求的结果
      5. <font color = red>第三层</font>的正确性作为衡量算法是否合格的标准
   2. 可读性(Readability):
      1. 易于理解
      2. 晦涩难懂的算法易于隐藏较多的错误而难以调试
   3. 健壮性(Robustness):**鲁棒性**
      1. 指的是当输入*非法数据*时，算法恰当的做出反应或进行相应处理，而非产生莫名奇妙的输出结果
      2. 处理错误方法，*不是中断程序的执行*，而应是返回一个表示错误或错误性质的值，以便在更高抽象层次上处理
   4. 高效性(Efficiency)：空间复杂度和时间复杂度都比较小
### 2.算法的标准
1. 标准：首先具有正确性，然后是健壮性，可读性，在这几个方面满足的情况下，主要考虑<font color = red>算法效率</font>，通过算法效率高低来评判不同算法的优劣程度
2. 效率
   1. <font color = red>时间效率</font>：算法所耗费的时间
   2. 空间效率：算法在执行时的耗费的存储空间
   3. <font color = blue>问题：时间效率和空间效率是矛盾的</font>
3. 算法时间效率的度量
   1. 算法的时间效率可以通过编制该算法的程序在计算机上执行的所*消耗的时间*来度量
   2. 度量方法
      1. 事后统计：将算法实现，测量时间和空间开销
         1. 1个算法的运行时间是指一个算法在计算机上运行所耗费时间大致等于计算机执行一种<font color = blue>简单操作(赋值，比较，移动等)所需要的时间与算法中进行的简单操作的次数的乘积</font>
         2. 公式: $算法运行时间 = 一个简单操作所需时间 x 简单操作次数$ < = > $\sum每条语句的执行次数(频度) x 该语句执行一次的时间$
            1. (*其中每条语句的执行次数为频度*)
            2. 每条语句的执行速度，取决于机器的**指令性能，速度和编译代码的质量**，是有机器本身的软硬件环境决定的，与算法无关
            3. 所以，<font color = red>可假执行每条语句的所需时间为*单位时间*，此时对算法的运行时间 = 该算法中所有语句的执行次数之和，即频度之和</font>
         3. 例如2个nxn矩阵相乘的算法可描述为
      ```cpp
      #include <iostream>
      using namespace std;
      //1.方法1
      void  multiMatrix(int a[][3], int b[][3]){
          int n = 3, m = 3, p = 3;//A = [nxm], B = [mxp], c = [nxp]
          int c[100][100] = {0};
          //赋值后输出
          for (int i = 0; i < n; i++){
              for (int j = 0; j < p; j++){
                  for (int k = 0; k < m; k++)
                  c[i][j] += a[i][k] * b[k][j];
              }
          }
          for (int i = 0; i < n; i++){
              for (int j = 0; j < p; j++){
                  cout << c[i][j] << " ";
              }
              cout << endl;
          }
      }
      //方法2
      void multiMatrixTest(){
          int a[100][100] = {0};
          int b[100][100] = {0};
          int c[100][100] = {0};
          int n = 0, m = 0, p = 0;//A = [nxm], B = [mxp], c = [nxp]
          cin >> n >> m;
          for (int i = 0; i < n; i++){
              for (int j = 0; j < m; j++){
                  scanf("%d", &a[i][j]);
              }
          }
          cin >> p;
          for (int i = 0; i < m; i++){
              for (int j = 0; j < p; j++){
                  scanf("%d", &b[i][j]);
              }
          }
          
          for (int i = 0; i < n; i++){
              for (int j = 0; j < p; j++){
                  for (int k = 0; k < m; k++){
                      c[i][j] += a[i][k] * b[k][j];
                  }
              }
          }

          for (int i = 0; i < n; i++){
              for (int j = 0; j < p; j++){
                      cout << c[i][j] << " ";
                  }
              cout << endl;
              }
      }

      int main(){
          int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
          int b[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
          // multiMatrix(a, b);
          multiMatrixTest();
          
      }
      /*
      1.1维数组传参:
      1-1.整形数组:对于:int arr[10] = {0}
      void test(int arr[])
      void test(int arr[10])
      void test(int *arr)
      1-2.指针数组:对于:int *arr[20] = {0};
      void test(int *arr[10])
      void test(int *arr)

      2.2维数组传参:例如int arr[3][5] = {0};
      void test(int arr[3][5])
      void test(int arr[][4])//必须知道列，行可以不知道

      */
      ```
      ```cpp
      for (i = 1; i <= n; i++)//由于条件不满足要退出循环，所以要最终执行n+1次
         for (j = 1; j <=n; j++)//n(n+1)
            c[i][j] = 0;//n*n
            for (k = 0; k < n; k++)//n * n* (n+1)
               c[i][j] += a[i][k]*b[k][j]//n*n*n
      /*
      T(n) = 2n^3 + 3n^2 + 2n + 1(关于n的函数)
      */
      ```

      2. 把算法所消耗的时间定义为*该算法中每条语句的频度之和*， 则上述算法的时间消耗为: T(n) = 2n^3 + 3n^2 + 2n + 1(关于n的函数)
      3. 为了便于比较不同算法的时间效率， 我们仅仅比较他们的数量级:
         1. 例如两个不同算法,时间消耗为 $T_{1}(n) = 10n^2$和$T_{2}(n) = 5n^3$，哪个好？
      4. 若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限为*不等于0的常数*，则称f(n)为T(n)的同数量级函数，记作<font color = red>T(n) = O(f(n)), 称O(f(n))为算法的渐进时间复杂度，简称时间复杂度(O = order)</font>
      5. 对于本例子,算法耗费时间:T(n) = 2n^3 + 3n^2 + 2n + 1, T(n)/n^3 = 2(n->无穷)，则T(n) = O(n^3)
      6. 注意
         1. *注意：一般情况下，不必计算所有操作的执行次数，而只考虑算法中<font color = red>基本操作</font>执行次数，用T(n)表示*, **基本语句是对执行次数贡献最大的语句**
         2. 算法中基本语句重复执行的次数是问题规模n的某个函数f(n), 算法的时间量度为:*T(n) = O(f(n))*,他表示随着增大，算法执行的时间的增长率和f(n)的增长率相同，称渐进时间复杂度。他表示随着n的增大，算法执行的时间增长率和f(n)的增长率相同，称为渐进时间复杂度。
      7. 复杂度定义：算法中重复执行次数和算法的执行时间成正比的语句；对算法运行时间贡献最大，执行次数最多的语句
4. 事前分析：对算法所消耗资源的估算方法

### 3.分析算法实现
